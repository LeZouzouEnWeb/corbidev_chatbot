<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon Assistant IA</title>
    <!-- Import de Tailwind CSS (Via CDN pour la simplicit√© de la formation) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import d'une police sympa (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Import des ic√¥nes (Lucide) -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Markdown parser + sanitizer pour interpr√©ter les r√©ponses -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Masquer la barre de d√©filement tout en gardant le scroll */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Loading spinner dots */
        .loading-dots {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            justify-content: center;
        }
        .loading-dots span {
            width: 6px;
            height: 6px;
            background: #1d4ed8; /* tailwind blue-700 */
            border-radius: 50%;
            opacity: 0.8;
            transform: translateY(0);
            animation: bounce 1s infinite ease-in-out;
        }
        .loading-dots span:nth-child(2) { animation-delay: 0.12s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.24s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: translateY(0); opacity: 0.8; }
            40% { transform: translateY(-6px); opacity: 1; }
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen relative p-4">

    <!-- Bulle de chat - bouton flottant en bas √† droite -->
    <button id="openChatBubble" aria-haspopup="dialog" aria-expanded="false" aria-label="Ouvrir le chat"
        class="fixed right-5 bottom-5 z-50 bg-blue-600 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center hover:bg-blue-700 transition-transform transform hover:scale-105">
        <i data-lucide="message-square" class="w-6 h-6"></i>
    </button>

    <!-- Modal chat - cach√©e par d√©faut -->
    <div id="chatModal" class="fixed inset-0 hidden items-center justify-center bg-black/40 z-40">
        <!-- Conteneur Principal du Chatbot -->
        <div id="chatPanel" class="bg-white w-full max-w-md h-[80vh] rounded-2xl shadow-xl flex flex-col overflow-hidden border border-gray-200 relative">
            <!-- HEADER : En-t√™te du chatbot -->
            <header class="bg-blue-600 p-4 text-white flex items-center justify-between shadow-sm">
                <div class="flex items-center gap-2">
                    <!-- Ic√¥ne Robot -->
                    <i data-lucide="bot" class="w-6 h-6"></i>
                    <h1 class="font-semibold text-lg">Assistant IA</h1>
                </div>
                <div id="serverKeyStatus" class="text-xs bg-blue-500 px-2 py-1 rounded-full flex items-center gap-1">
                    <span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
                    En ligne
                </div>
                <!-- Button to open API key modal -->
                <button id="openKeyModal" title="Configurer la cl√© OpenAI" class="ml-2 bg-blue-500/40 rounded px-2 py-1 text-xs">üîë</button>
                <button id="clearHistoryBtn" title="Effacer la conversation" class="ml-2 bg-red-500/40 hover:bg-red-600/20 rounded px-2 py-1 text-xs">üßπ</button>
                <label class="ml-2 text-xs flex items-center gap-1"><input id="rememberCheckbox" type="checkbox" class="rounded"/> Se souvenir</label>
                <label class="ml-2 text-xs flex items-center gap-1" title="Utiliser la base de connaissance Maine Coon"><input id="useKnowledgeCheckbox" type="checkbox" class="rounded" checked/> Base de connaissance</label>
                <label class="ml-2 text-xs flex items-center gap-1" title="R√©ponses courtes"><input id="shortResponsesCheckbox" type="checkbox" class="rounded"/> R√©ponses courtes</label>
                <label class="ml-2 text-xs flex items-center gap-1" title="Styliser les r√©ponses (MD + Emojis + Couleurs)"><input id="stylizedCheckbox" type="checkbox" class="rounded"/> Stylis√©</label>
                <div class="ml-2 text-xs flex items-center gap-1">
                    <span id="maxCharsDisplay" class="px-2 py-1 rounded bg-blue-400/20 text-blue-700 text-xs">Max: ?</span>
                    <button id="setMaxCharsBtn" title="D√©finir la limite de caract√®res" class="ml-2 bg-blue-500/30 px-2 py-1 rounded text-xs">‚öôÔ∏è</button>
                </div>
            </header>

            <!-- ZONE DE CHAT : L√† o√π les messages s'affichent -->
            <!-- flex-1 permet de prendre tout l'espace disponible -->
            <div id="chat-container" class="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50 no-scrollbar">
                <!-- Exemple de message de l'IA (Message de bienvenue) -->
                <div class="flex items-start gap-2.5">
                    <div class="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center text-blue-600">
                        <i data-lucide="bot" class="w-5 h-5"></i>
                    </div>
                    <div class="flex flex-col gap-1 w-full max-w-[320px]">
                        <div class="flex items-center space-x-2 rtl:space-x-reverse">
                            <span class="text-sm font-semibold text-gray-900">IA</span>
                            <span class="text-xs font-normal text-gray-500">Maintenant</span>
                        </div>
                        <div class="flex flex-col leading-1.5 p-4 border-gray-200 bg-white rounded-e-xl rounded-es-xl shadow-sm">
                            <p class="text-sm font-normal text-gray-900">Bonjour ! Je suis votre assistant virtuel. Comment puis-je vous aider aujourd'hui ?</p>
                        </div>
                    </div>
                </div>

                <!-- Exemple de message Utilisateur (Pour visualiser le design) -->
                <!--
            <div class="flex items-start gap-2.5 justify-end">
                <div class="flex flex-col gap-1 w-full max-w-[320px]">
                    <div class="flex items-center justify-end space-x-2 rtl:space-x-reverse">
                        <span class="text-xs font-normal text-gray-500">Maintenant</span>
                        <span class="text-sm font-semibold text-gray-900">Vous</span>
                    </div>
                    <div class="flex flex-col leading-1.5 p-4 border-gray-200 bg-blue-600 text-white rounded-s-xl rounded-ee-xl shadow-sm">
                        <p class="text-sm font-normal">Peux-tu m'expliquer le code HTML ?</p>
                    </div>
                </div>
            </div>
            -->
            </div>

            <!-- FOOTER : Zone de saisie -->
            <div class="p-4 bg-white border-t border-gray-100">
                <form class="flex items-center gap-2" onsubmit="event.preventDefault();">
                    <input type="text" id="user-input" class="flex-1 border border-gray-300 rounded-full px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm" placeholder="√âcrivez votre message...">
                    <button id="sendBtn" type="submit" class="bg-blue-600 hover:bg-blue-700 text-white rounded-full p-2 transition-colors flex items-center justify-center">
                        <i data-lucide="send" class="w-5 h-5"></i>
                    </button>
                </form>
            </div>

            <!-- Bouton fermer chat -->
            <button id="closeChatBtn" aria-label="Fermer le chat" class="absolute right-3 top-3 text-gray-500">‚úñ</button>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="keyModal" class="fixed inset-0 hidden items-center justify-center bg-black/40 z-40">
        <div class="bg-white rounded-md shadow-lg p-6 w-full max-w-md">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-lg font-semibold">Cl√© OpenAI</h2>
                <button id="closeKeyModal" class="text-gray-500">‚úñ</button>
            </div>
            <div class="space-y-3">
                <p class="text-sm text-gray-600">Entrez votre cl√© OpenAI (ex: sk-... ). Elle sera enregistr√©e localement dans <code>.env</code>.</p>
                <input id="apiKeyInput" class="w-full border px-3 py-2 rounded" placeholder="sk-xxx..." />
                <div class="pt-2">
                    <label for="modelSelect" class="text-sm text-gray-600">Choisir le mod√®le</label>
                    <select id="modelSelect" class="w-full border px-3 py-2 rounded mt-1">
                        <option value="gpt-4o-mini">gpt-4o-mini</option>
                        <option value="gpt-4o">gpt-4o</option>
                        <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                        <option value="gpt-3.5-turbo-16k">gpt-3.5-turbo-16k</option>
                        <option value="text-davinci-003">text-davinci-003</option>
                    </select>
                </div>
                <div class="flex items-center justify-between gap-2">
                    <button id="saveKeyBtn" class="bg-blue-600 text-white px-4 py-2 rounded">Enregistrer la cl√©</button>
                    <button id="saveModelBtn" class="bg-blue-500 text-white px-4 py-2 rounded">Enregistrer le mod√®le</button>
                    <button id="testKeyBtn" class="bg-gray-200 text-gray-800 px-4 py-2 rounded">Tester</button>
                </div>
                <p id="modalStatus" class="text-xs text-gray-500"></p>
            </div>
        </div>
    </div>

    <!-- Script pour initialiser les ic√¥nes -->
    <script>
        // Frontend: UI logic for the chat widget.
        // Purpose:
        // - Small floating bubble opens a modal chat window
        // - Users can set their OpenAI API key locally, choose a model, and send messages
        // - Messages are persisted (optionally) in localStorage to maintain conversation
        // - The assistant's responses are rendered as sanitized HTML using marked + DOMPurify
        // Security note: API keys are saved to `.env` on the server for convenience in this demo.
        // In production, keys must never be stored this way.
        lucide.createIcons();
        // Show whether the API key is configured on the server
        async function updateKeyStatus() {
            try {
                const r = await fetch('/config');
                const j = await r.json();
                const el = document.getElementById('serverKeyStatus');
                if (j.keySet) {
                    el.classList.remove('bg-red-500');
                    el.classList.add('bg-blue-500');
                    el.innerHTML = '<span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span> En ligne';
                } else {
                    el.classList.remove('bg-blue-500');
                    el.classList.add('bg-red-500');
                    el.innerHTML = '<span class="w-2 h-2 bg-orange-400 rounded-full animate-pulse"></span> Cl√© manquante';
                }
                // update the model selector with the server default
                if (j.model && modelSelect) {
                    try { modelSelect.value = j.model; } catch (e) { /* ignore if not present */ }
                }
                // show the current maxResponseChars if present
                if (j.maxResponseChars) {
                    try { document.getElementById('maxCharsDisplay').textContent = 'Max: ' + j.maxResponseChars; } catch (e) {}
                }
                // update the client-side history limit if provided by the server
                if (j.historyMaxMessages) {
                    try { HISTORY_MAX_MESSAGES = parseInt(j.historyMaxMessages, 10) || HISTORY_MAX_MESSAGES; } catch (e) {}
                }
                // update default UI flags coming from server config
                if (typeof j.defaultUseKnowledge !== 'undefined' && !localStorage.getItem('use_knowledge')) {
                    useKnowledgeCheckbox.checked = !!j.defaultUseKnowledge;
                }
                if (typeof j.defaultStylizeResponse !== 'undefined' && !localStorage.getItem('stylized_response')) {
                    stylizedCheckbox.checked = !!j.defaultStylizeResponse;
                }
                if (typeof j.defaultShortResponse !== 'undefined' && !localStorage.getItem('short_responses')) {
                    shortResponsesCheckbox.checked = !!j.defaultShortResponse;
                }
                if (typeof j.defaultRememberHistory !== 'undefined' && !localStorage.getItem('remember_history')) {
                    rememberCheckbox.checked = !!j.defaultRememberHistory;
                    rememberHistory = !!j.defaultRememberHistory;
                }
            } catch (err) {
                console.warn('Could not fetch config', err);
            }
        }
        // do not call updateKeyStatus until page variables are defined (modelSelect)
        // --- Simple chat UI + modal logic + conversation history
        // In-memory conversation history. Persisted to localStorage only if the user enables "Se souvenir".
        // Structure: [{ role: 'user'|'assistant'|'system', content: '...' }, ...]
        let conversationHistory = [];
        // Client-side limit for history that mirrors server's HISTORY_MAX_MESSAGES
        // This is updated dynamically when the UI fetches `/config`.
        let HISTORY_MAX_MESSAGES = 24; // keep last X messages
        let rememberHistory = false;
        // UI references
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('sendBtn');
        const openKeyModalBtn = document.getElementById('openKeyModal');
        const keyModal = document.getElementById('keyModal');
        const closeKeyModalBtn = document.getElementById('closeKeyModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveKeyBtn = document.getElementById('saveKeyBtn');
        const saveModelBtn = document.getElementById('saveModelBtn');
        const testKeyBtn = document.getElementById('testKeyBtn');
        const modalStatus = document.getElementById('modalStatus');
        const modelSelect = document.getElementById('modelSelect');
        const openChatBubbleBtn = document.getElementById('openChatBubble');
        const chatModal = document.getElementById('chatModal');
        const closeChatBtn = document.getElementById('closeChatBtn');

        // Append a message to the chat UI
        // role: 'user' | 'assistant'
        // text: message text (assistant messages are sanitized and rendered as Markdown)
        // skipHistory: if true, the message will not be stored into `conversationHistory` (useful when re-hydrating)
        function appendMessage(role, text, skipHistory=false) {
            const wrapper = document.createElement('div');
            wrapper.className = role === 'user' ? 'flex items-start gap-2.5 justify-end' : 'flex items-start gap-2.5';
            const inner = document.createElement('div');
            inner.className = 'flex flex-col gap-1 w-full max-w-[320px]';
            const profile = document.createElement('div');
            profile.className = 'flex items-center ' + (role === 'user' ? 'justify-end space-x-2 rtl:space-x-reverse' : 'space-x-2');
            const name = document.createElement('span');
            name.className = 'text-sm font-semibold text-gray-900';
            name.textContent = role === 'user' ? 'Vous' : 'IA';
            const time = document.createElement('span');
            time.className = 'text-xs font-normal text-gray-500';
            time.textContent = 'Maintenant';
            profile.appendChild(role === 'user' ? time : name);
            profile.appendChild(role === 'user' ? name : time);

            const bubble = document.createElement('div');
            bubble.className = role === 'user' ? 'leading-1.5 p-4 border-gray-200 bg-blue-600 text-white rounded-s-xl rounded-ee-xl shadow-sm' : 'leading-1.5 p-4 border-gray-200 bg-white rounded-e-xl rounded-es-xl shadow-sm';
            // Assistant messages are treated as Markdown and sanitized
            if (role === 'assistant') {
                // Render markdown + sanitize + convert color tags
                try {
                    const html = renderAssistantMarkdown(text);
                    bubble.innerHTML = html;
                } catch (e) {
                    bubble.innerHTML = '<p class="text-sm font-normal">' + text.replace(/\n/g, '<br>') + '</p>';
                }
            } else {
                bubble.innerHTML = '<p class="text-sm font-normal">' + text.replace(/\n/g, '<br>') + '</p>';
            }

            inner.appendChild(profile);
            inner.appendChild(bubble);
            wrapper.appendChild(inner);
            chatContainer.appendChild(wrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            // Optionally store in memory/localStorage ‚Äî trim to the last HISTORY_MAX_MESSAGES
            if (!skipHistory) {
                // push to memory
                conversationHistory.push({ role, content: text });
                // trim
                if (conversationHistory.length > HISTORY_MAX_MESSAGES) {
                    conversationHistory = conversationHistory.slice(-HISTORY_MAX_MESSAGES);
                }
                // persist if requested
                if (rememberHistory) {
                    try { localStorage.setItem('chat_history', JSON.stringify(conversationHistory)); } catch (e) { /* ignore */ }
                }
            }
        }

        // Show a loading indicator while waiting for the assistant response
        function showLoading() {
            // remove previous if any
            const existing = document.getElementById('loadingBubble');
            if (existing) existing.remove();
            const wrapper = document.createElement('div');
            wrapper.className = 'flex items-start gap-2.5';
            wrapper.id = 'loadingBubble';
            const profile = document.createElement('div');
            profile.className = 'w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center text-blue-600';
            profile.innerHTML = '<i data-lucide="bot" class="w-5 h-5"></i>';
            const inner = document.createElement('div');
            inner.className = 'flex flex-col gap-1 w-full max-w-[320px]';
            const bubble = document.createElement('div');
            bubble.className = 'leading-1.5 p-4 border-gray-200 bg-white rounded-e-xl rounded-es-xl shadow-sm';
            // spinner
            bubble.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
            inner.appendChild(bubble);
            wrapper.appendChild(profile);
            wrapper.appendChild(inner);
            chatContainer.appendChild(wrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            // disable input
            try { userInput.setAttribute('disabled', 'disabled'); sendBtn.setAttribute('disabled', 'disabled'); } catch (e) {}
            try { lucide.createIcons(); } catch (e) {}
        }

        // Remove the loading indicator and re-enable the input
        function hideLoading() {
            const existing = document.getElementById('loadingBubble');
            if (existing) existing.remove();
            try { userInput.removeAttribute('disabled'); sendBtn.removeAttribute('disabled'); } catch (e) {}
        }

        // Form submission: send user's message to the server via POST /chat, including conversation history
        document.querySelector('form').addEventListener('submit', async () => {
            const text = userInput.value.trim();
            if (!text) return;
            // send previous history to server, not including current input
            const historyToSend = conversationHistory.slice();
            appendMessage('user', text);
            showLoading();
            userInput.value = '';
            try {
                // POST /chat: message payload includes `message`, `model`, `history`, and UI flags
                const res = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text, model: modelSelect.value, history: historyToSend, useKnowledge: useKnowledgeCheckbox.checked, shortResponse: shortResponsesCheckbox.checked, stylizeResponse: stylizedCheckbox.checked })
                });
                const json = await res.json();
                if (!json.ok) {
                    hideLoading();
                    appendMessage('assistant', 'Erreur: ' + (json.error || 'r√©ponse inattendue')); // assistant alias
                    return;
                }
                hideLoading();
                appendMessage('assistant', json.reply || 'Aucune r√©ponse');
            } catch (err) {
                hideLoading();
                appendMessage('assistant', 'Erreur lors de la requ√™te: ' + err.message);
            }
        });

        // Modal open/close handlers
        openKeyModalBtn.addEventListener('click', () => keyModal.classList.remove('hidden'));
        closeKeyModalBtn.addEventListener('click', () => keyModal.classList.add('hidden'));

        // Open/close chat modal via bubble
        openChatBubbleBtn.addEventListener('click', () => {
            chatModal.classList.remove('hidden');
            chatModal.classList.add('flex');
            openChatBubbleBtn.setAttribute('aria-expanded', 'true');
            // focusable for quick typing
            setTimeout(() => userInput.focus(), 150);
        });
        closeChatBtn.addEventListener('click', () => {
            chatModal.classList.add('hidden');
            chatModal.classList.remove('flex');
            openChatBubbleBtn.setAttribute('aria-expanded', 'false');
            openChatBubbleBtn.focus();
        });
        // allow clicking outside panel to close
        chatModal.addEventListener('click', (e) => {
            if (e.target === chatModal) {
                chatModal.classList.add('hidden');
                chatModal.classList.remove('flex');
                openChatBubbleBtn.setAttribute('aria-expanded', 'false');
                openChatBubbleBtn.focus();
            }
        });
        // Escape to close
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !chatModal.classList.contains('hidden')) {
                chatModal.classList.add('hidden');
                chatModal.classList.remove('flex');
                openChatBubbleBtn.setAttribute('aria-expanded', 'false');
                openChatBubbleBtn.focus();
            }
        });

        // Save the API key on the server for convenience. Reminder: do not do this for production.
        saveKeyBtn.addEventListener('click', async () => {
            const key = apiKeyInput.value.trim();
            if (!key) { modalStatus.textContent = 'Cl√© manquante'; return; }
            modalStatus.textContent = 'Enregistrement...';
            try {
                const res = await fetch('/set-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key })
                });
                const json = await res.json();
                if (!json.ok) throw new Error(json.error || 'Erreur');
                modalStatus.textContent = 'Cl√© enregistr√©e ‚Äî red√©marrez le serveur pour la prendre en compte.';
                // Clear or advise about not saving model here ‚Äî model persistence is now separate
                modalStatus.textContent += ' (Mod√®le non modifi√©)';
            } catch (err) {
                modalStatus.textContent = 'Erreur: ' + err.message;
            }
        });

        // Save chosen model server-side so the server defaults to it for subsequent requests
        // This persists to `.env` via the server `/set-model` endpoint.
        // Model options are available to override per request from the client.
        // New handler: save only the model via /set-model
        saveModelBtn.addEventListener('click', async () => {
            const chosenModel = modelSelect.value;
            modalStatus.textContent = 'Enregistrement du mod√®le...';
            try {
                const r = await fetch('/set-model', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model: chosenModel }) });
                const j = await r.json();
                if (!j.ok) throw new Error(j.error || 'Erreur en enregistrant le mod√®le');
                modalStatus.textContent = 'Mod√®le enregistr√©: ' + chosenModel;
                updateKeyStatus();
                // update header status to reflect new model if needed
            } catch (err) {
                modalStatus.textContent = 'Erreur (mod√®le): ' + err.message;
            }
        });

        // Test the provided API key by temporarily writing it to the server and calling the chat endpoint
        testKeyBtn.addEventListener('click', async () => {
            modalStatus.textContent = 'Test en cours...';
            const key = apiKeyInput.value.trim();
            if (!key) { modalStatus.textContent = 'Cl√© manquante'; return; }
            try {
                // Keep a simple quick test (do not store); call /chat with a test prompt by proxy to validate key
                const testPrompt = 'Say hello in one sentence.';
                // Temporary test: we call the server set-key then test chat instantly
                // We use set-key to temporarily write and then call /chat
                const setRes = await fetch('/set-key', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key })
                });
                const setJson = await setRes.json();
                if (!setJson.ok) throw new Error(setJson.error || 'Failed to set');

                const chatRes = await fetch('/chat', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: testPrompt, model: modelSelect.value })
                });
                const chatJson = await chatRes.json();
                if (!chatJson.ok) throw new Error(chatJson.error || 'Chat failed');
                modalStatus.textContent = 'Cl√© OK ‚Äî r√©ponse test: ' + (chatJson.reply || 'pas de r√©ponse');
            } catch (err) {
                modalStatus.textContent = '√âchec du test: ' + err.message;
            }
        });
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const rememberCheckbox = document.getElementById('rememberCheckbox');
        const useKnowledgeCheckbox = document.getElementById('useKnowledgeCheckbox');
        const shortResponsesCheckbox = document.getElementById('shortResponsesCheckbox');
        const stylizedCheckbox = document.getElementById('stylizedCheckbox');
        const setMaxCharsBtn = document.getElementById('setMaxCharsBtn');
        rememberHistory = !!localStorage.getItem('remember_history');
        rememberCheckbox.checked = rememberHistory;
        // Restore persisted setting for knowledge base
        try {
            const s = localStorage.getItem('use_knowledge');
            if (s !== null) {
                useKnowledgeCheckbox.checked = s === '1';
            } else {
                useKnowledgeCheckbox.checked = true; // default
            }
        } catch (e) { useKnowledgeCheckbox.checked = true; }
        // restore short response setting
        try {
            const r = localStorage.getItem('short_responses');
            shortResponsesCheckbox.checked = r === '1';
        } catch (e) { shortResponsesCheckbox.checked = false; }
        // restore stylized setting
        try {
            const r = localStorage.getItem('stylized_response');
            stylizedCheckbox.checked = r === '1';
        } catch (e) { stylizedCheckbox.checked = true; }

        // Clear the conversation both in-memory and in localStorage
        clearHistoryBtn.addEventListener('click', () => {
            conversationHistory = [];
            localStorage.removeItem('chat_history');
            chatContainer.innerHTML = '';
            appendMessage('assistant', 'Bonjour ! Je suis votre assistant virtuel. Comment puis-je vous aider aujourd\'hui ?');
        });

        // Toggle memory persistence: when enabled, conversationHistory is also saved to localStorage
        rememberCheckbox.addEventListener('change', () => {
            rememberHistory = rememberCheckbox.checked;
            try {
                localStorage.setItem('remember_history', rememberHistory ? '1' : '0');
            } catch (e) { }
            if (!rememberHistory) {
                localStorage.removeItem('chat_history');
            } else {
                try { localStorage.setItem('chat_history', JSON.stringify(conversationHistory)); } catch (e) { }
            }
        });

        useKnowledgeCheckbox.addEventListener('change', () => {
            try { localStorage.setItem('use_knowledge', useKnowledgeCheckbox.checked ? '1' : '0'); } catch (e) { }
        });
        shortResponsesCheckbox.addEventListener('change', () => {
            try { localStorage.setItem('short_responses', shortResponsesCheckbox.checked ? '1' : '0'); } catch (e) { }
        });
        stylizedCheckbox.addEventListener('change', () => {
            try { localStorage.setItem('stylized_response', stylizedCheckbox.checked ? '1' : '0'); } catch (e) { }
        });

        // Allow the user to set the MAX_RESPONSE_CHARS server-side through /set-config
        if (setMaxCharsBtn) {
            setMaxCharsBtn.addEventListener('click', async () => {
                const currentText = document.getElementById('maxCharsDisplay').textContent || 'Max: ?';
                const current = parseInt(currentText.replace(/[^0-9]/g, ''), 10) || 1000;
                const input = prompt('D√©finir la limite de caract√®res pour les r√©ponses du chatbot (MAX_RESPONSE_CHARS):', String(current));
                if (!input) return;
                const n = parseInt(input, 10);
                if (Number.isNaN(n) || n < 10) { alert('Valeur invalide'); return; }
                try {
                    const r = await fetch('/set-config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: 'MAX_RESPONSE_CHARS', value: String(n) }) });
                    const j = await r.json();
                    if (!j.ok) throw new Error(j.error || 'Erreur');
                    // update the displayed value
                    document.getElementById('maxCharsDisplay').textContent = 'Max: ' + j.value;
                    alert('Max response chars mis √† jour: ' + j.value);
                } catch (err) {
                    alert('Erreur: ' + err.message);
                }
            });
        }

        useKnowledgeCheckbox.addEventListener('change', () => {
            try { localStorage.setItem('use_knowledge', useKnowledgeCheckbox.checked ? '1' : '0'); } catch (e) { }
        });

        // Hydrate persisted conversation from localStorage if present (and render it without duplicating history)
        chatContainer.innerHTML = '';
        (function loadPersistedHistory() {
            try {
                const r = localStorage.getItem('chat_history');
                if (r) {
                    const arr = JSON.parse(r);
                    if (Array.isArray(arr)) {
                        conversationHistory = arr.slice(-HISTORY_MAX_MESSAGES);
                        // render without pushing again to history
                        chatContainer.innerHTML = '';
                        for (const m of conversationHistory) {
                            appendMessage(m.role, m.content, true);
                        }
                        return;
                    }
                }
            } catch (e) {}
            // nothing persisted: show default
            appendMessage('assistant', 'Bonjour ! Je suis votre assistant virtuel. Comment puis-je vous aider aujourd\'hui ?');
        })();
        // now we can fetch server config and update UI status
        updateKeyStatus();
        // helper: render markdown with custom color tag handling
        function renderAssistantMarkdown(mdText) {
            // Convert custom [color=...] tags to inline styles before parsing markdown
            const colored = mdText.replace(/\[color=([^\]]+)\]([\s\S]*?)\[\/color\]/gi, (m, c, inner) => {
                // sanitize color to avoid injection - allow hex or simple color words
                const color = c.trim();
                return `<span style="color:${color}">${inner}</span>`;
            });
            // Use marked to parse markdown ‚Üí HTML
            const rawHtml = marked.parse(colored);
            // sanitize
            const safe = DOMPurify.sanitize(rawHtml, {ALLOWED_ATTR: ['href', 'target', 'style', 'class']});
            // Add emoji span styling (small touch)
            return `<p class="text-sm font-normal">${safe}</p>`;
        }
    </script>
</body>

</html>