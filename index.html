<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon Assistant IA</title>
    <!-- Import de Tailwind CSS (Via CDN pour la simplicité de la formation) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import d'une police sympa (Inter) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Import des icônes (Lucide) -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Markdown parser + sanitizer pour interpréter les réponses -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <style>
        /* Remplacer le style body pour un fond dégradé subtil */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }

        /* Masquer la barre de défilement tout en gardant le scroll */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {

                /* Links inside messages */
                #chat-container a,
                .bubble-assistant a,
                .bubble-user a {
                    color: #4f46e5; /* Indigo-600 */
                    text-decoration: underline;
                    text-underline-offset: 2px;
                    font-weight: 500;
                }
                #chat-container a:hover,
                .bubble-assistant a:hover,
                .bubble-user a:hover {
                    color: #6366f1; /* Indigo-500 */
                    text-decoration-thickness: 2px;
                }
                .assistant-link {
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                }
                .assistant-link::after {
                    content: '\2197';
                    font-size: 0.75rem;
                    opacity: 0.6;
                    margin-left: 4px;
                }
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Loading spinner amélioré avec dégradé */
        .loading-dots {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            justify-content: center;
        }

        .loading-dots span {
            width: 8px;
            height: 8px;
            background: linear-gradient(45deg, #6366f1, #8b5cf6);
            border-radius: 50%;
            opacity: 0.8;
            transform: translateY(0);
            animation: bounce 1s infinite ease-in-out;
        }

        .loading-dots span:nth-child(2) {
            animation-delay: 0.12s;
        }

        .loading-dots span:nth-child(3) {
            animation-delay: 0.24s;
        }

        @keyframes bounce {
            0%,
            80%,
            100% {
                transform: translateY(0);
                opacity: 0.8;
            }

            40% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        /* Ajout de styles pour glassmorphism sur le panel */
        #chatPanel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Avatar amélioré */
        .avatar-bot {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .avatar-user {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        /* Bulles de chat avec dégradé subtil */
        .bubble-assistant {
            background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .bubble-user {
            background: linear-gradient(145deg, #6366f1 0%, #8b5cf6 100%);
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3);
        }

        /* Header avec dégradé */
        header {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 50%, #ec4899 100%);
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
        }

        /* Bouton flottant amélioré */
        #openChatBubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #openChatBubble:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }

        /* Input focus ring plus joli */
        #user-input:focus {
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
            border-color: #6366f1;
        }

        /* Send button */
        #sendBtn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            transition: all 0.3s ease;
        }

        #sendBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        /* Modal backdrop plus sombre */
        #chatModal,
        #keyModal {
            backdrop-filter: blur(8px);
        }

        /* Réorganiser header : grouper checkboxes en dropdown settings pour moins de surcharge */
    </style>
</head>

<body class="bg-gray-100 min-h-screen relative p-4">

    <!-- Bulle de chat - bouton flottant en bas à droite -->
    <button id="openChatBubble" aria-haspopup="dialog" aria-expanded="false" aria-label="Ouvrir le chat"
        class="fixed right-5 bottom-5 z-50 w-16 h-16 rounded-2xl shadow-2xl flex items-center justify-center">
        <i data-lucide="message-square" class="w-6 h-6"></i>
    </button>

    <!-- Modal chat - cachée par défaut -->
    <div id="chatModal" class="fixed inset-0 hidden items-center justify-center bg-black/40 z-40">
        <!-- Conteneur Principal du Chatbot -->
        <div id="chatPanel" class="bg-white w-full max-w-md h-[80vh] rounded-2xl shadow-xl flex flex-col overflow-hidden border border-gray-200 relative">
            <!-- HEADER : En-tête du chatbot -->
            <header class="p-6 text-white flex flex-col lg:flex-row items-start lg:items-center justify-between gap-4 shadow-lg">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 avatar-bot rounded-2xl flex items-center justify-center">
                        <i data-lucide="bot" class="w-6 h-6"></i>
                    </div>
                    <h1 class="font-bold text-xl">Assistant IA</h1>
                    </div>
                    <div id="serverKeyStatus" class="text-sm bg-white/20 px-3 py-1.5 rounded-full flex items-center gap-2 backdrop-blur-sm">
                        <span class="w-2.5 h-2.5 bg-emerald-400 rounded-full animate-pulse"></span>
                    En ligne
                </div>
                <!-- Nouveau dropdown settings au lieu de tous les checkboxes -->
                <div class="flex items-center gap-2 relative">
                    <button id="settingsBtn"
                        class="bg-white/20 hover:bg-white/30 p-2 rounded-xl transition-all flex items-center gap-1 text-sm backdrop-blur-sm">
                        <i data-lucide="settings" class="w-4 h-4"></i> Options
                    </button>
                    <button id="openKeyModal" title="Clé API" class="bg-white/20 hover:bg-white/30 p-2 rounded-xl transition-all">
                        <i data-lucide="key" class="w-5 h-5"></i>
                    </button>
                    <button id="clearHistoryBtn" title="Effacer"
                        class="bg-white/20 hover:bg-white/30 p-2 rounded-xl transition-all text-red-300">
                        <i data-lucide="trash-2" class="w-5 h-5"></i>
                    </button>
                </div>
                <!-- Settings dropdown inserted so checkboxes exist for the JS logic -->
                <div id="settingsDropdown"
                    class="absolute top-full right-6 mt-2 bg-white/90 backdrop-blur-xl rounded-2xl shadow-2xl p-4 w-72 border border-white/50 hidden flex flex-col gap-3 z-50">
                    <label class="flex items-center gap-2 text-sm"><input id="rememberCheckbox" type="checkbox" class="rounded" /> Se
                        souvenir</label>
                    <label class="flex items-center gap-2 text-sm"><input id="useKnowledgeCheckbox" type="checkbox" class="rounded"
                            checked /> Base Maine Coon</label>
                    <label class="flex items-center gap-2 text-sm"><input id="shortResponsesCheckbox" type="checkbox" class="rounded" />
                        Réponses courtes</label>
                    <label class="flex items-center gap-2 text-sm"><input id="stylizedCheckbox" type="checkbox" class="rounded"
                            checked /> Stylisé</label>
                    <div class="flex gap-2 items-center">
                        <span id="maxCharsDisplay" class="px-2 py-1 rounded bg-indigo-100 text-indigo-700 text-xs">Max: 1000</span>
                        <button id="setMaxCharsBtn" title="Limiter"
                            class="bg-indigo-500 text-white px-2 py-1 rounded text-xs hover:bg-indigo-600">⚙️</button>
                    </div>
                </div>
            </header>

            <!-- ZONE DE CHAT : Là où les messages s'affichent -->
            <!-- flex-1 permet de prendre tout l'espace disponible -->
            <div id="chat-container"
                class="flex-1 overflow-y-auto p-6 space-y-4 bg-gradient-to-b from-slate-50 to-white no-scrollbar">
                <!-- Exemple de message de l'IA (Message de bienvenue) -->
                <div class="flex items-start gap-2.5">
                    <div class="w-10 h-10 avatar-bot rounded-2xl flex items-center justify-center text-white shrink-0">
                        <i data-lucide="bot" class="w-6 h-6"></i>
                    </div>
                    <div class="flex flex-col gap-1 w-full max-w-[320px]">
                        <div class="flex items-center space-x-2 rtl:space-x-reverse">
                            <span class="text-sm font-semibold text-slate-900">IA</span>
                            <span class="text-xs font-normal text-slate-500">Maintenant</span>
                        </div>
                        <div class="bubble-assistant p-5 rounded-2xl shadow-lg">
                            <p class="text-sm font-normal text-slate-900 leading-relaxed">Bonjour ! Je suis votre assistant virtuel. Comment
                                puis-je vous aider aujourd'hui ?</p>
                        </div>
                    </div>
                </div>

                <!-- Exemple de message Utilisateur (Pour visualiser le design) -->
                <!--
            <div class="flex items-start gap-2.5 justify-end">
                <div class="flex flex-col gap-1 w-full max-w-[320px]">
                    <div class="flex items-center justify-end space-x-2 rtl:space-x-reverse">
                        <span class="text-xs font-normal text-slate-500">Maintenant</span>
                        <span class="text-sm font-semibold text-white">Vous</span>
                    </div>
                    <div class="bubble-user p-5 rounded-2xl shadow-lg">
                        <p class="text-sm font-normal text-white leading-relaxed">Peux-tu m'expliquer le code HTML ?</p>
                    </div>
                </div>
            </div>
            -->
            </div>

            <!-- FOOTER : Zone de saisie -->
            <div class="p-6 bg-white/80 backdrop-blur-sm border-t border-slate-200/50">
                <form class="flex items-center gap-3" onsubmit="event.preventDefault();">
                    <input type="text" id="user-input"
                        class="flex-1 border-2 border-slate-200 rounded-2xl px-5 py-3 focus:outline-none focus:border-indigo-500 text-sm placeholder-slate-500 shadow-sm transition-all"
                        placeholder="Tapez votre message...">
                    <button id="sendBtn" type="submit" class="w-12 h-12 rounded-2xl flex items-center justify-center shadow-lg">
                        <i data-lucide="send" class="w-6 h-6"></i>
                    </button>
                </form>
            </div>

            <!-- Bouton fermer chat -->
            <button id="closeChatBtn" aria-label="Fermer"
                class="absolute right-4 top-4 bg-white/80 hover:bg-white p-2 rounded-xl shadow-md transition-all text-slate-600 hover:text-slate-900">
                <i data-lucide="x" class="w-5 h-5"></i>
            </button>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="keyModal" class="fixed inset-0 hidden items-center justify-center bg-black/40 z-40">
        <div class="bg-white/95 backdrop-blur-xl rounded-3xl shadow-2xl p-8 w-full max-w-sm border border-white/50">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-lg font-semibold">Clé OpenAI</h2>
                <button id="closeKeyModal" class="text-gray-500">✖</button>
            </div>
            <div class="space-y-3">
                <p class="text-sm text-gray-600">Entrez votre clé OpenAI (ex: sk-... ). Elle sera enregistrée localement dans <code>.env</code>.</p>
                <input id="apiKeyInput" class="w-full border px-3 py-2 rounded" placeholder="sk-xxx..." />
                <div class="pt-2">
                    <label for="modelSelect" class="text-sm text-gray-600">Choisir le modèle</label>
                    <select id="modelSelect" class="w-full border px-3 py-2 rounded mt-1">
                        <option value="gpt-4o-mini">gpt-4o-mini</option>
                        <option value="gpt-4o">gpt-4o</option>
                        <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                        <option value="gpt-3.5-turbo-16k">gpt-3.5-turbo-16k</option>
                        <option value="text-davinci-003">text-davinci-003</option>
                    </select>
                </div>
                <div class="flex items-center justify-between gap-2">
                    <button id="saveKeyBtn" class="bg-blue-600 text-white px-4 py-2 rounded">Enregistrer la clé</button>
                    <button id="saveModelBtn" class="bg-blue-500 text-white px-4 py-2 rounded">Enregistrer le modèle</button>
                    <button id="testKeyBtn" class="bg-gray-200 text-gray-800 px-4 py-2 rounded">Tester</button>
                </div>
                <p id="modalStatus" class="text-xs text-gray-500"></p>
            </div>
        </div>
    </div>

    <!-- Script pour initialiser les icônes -->
    <script>
        // Frontend: UI logic for the chat widget.
        // Purpose:
        // - Small floating bubble opens a modal chat window
        // - Users can set their OpenAI API key locally, choose a model, and send messages
        // - Messages are persisted (optionally) in localStorage to maintain conversation
        // - The assistant's responses are rendered as sanitized HTML using marked + DOMPurify
        // Security note: API keys are saved to `.env` on the server for convenience in this demo.
        // In production, keys must never be stored this way.
        lucide.createIcons();
        // Show whether the API key is configured on the server
        async function updateKeyStatus() {
            try {
                const r = await fetch('/config');
                const j = await r.json();
                const el = document.getElementById('serverKeyStatus');
                if (j.keySet) {
                    el.classList.remove('bg-red-500');
                    el.classList.add('bg-blue-500');
                    el.innerHTML = '<span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span> En ligne';
                } else {
                    el.classList.remove('bg-blue-500');
                    el.classList.add('bg-red-500');
                    el.innerHTML = '<span class="w-2 h-2 bg-orange-400 rounded-full animate-pulse"></span> Clé manquante';
                }
                // update the model selector with the server default
                if (j.model && modelSelect) {
                    try { modelSelect.value = j.model; } catch (e) { /* ignore if not present */ }
                }
                // show the current maxResponseChars if present
                if (j.maxResponseChars) {
                    try { document.getElementById('maxCharsDisplay').textContent = 'Max: ' + j.maxResponseChars; } catch (e) {}
                }
                // update the client-side history limit if provided by the server
                if (j.historyMaxMessages) {
                    try { HISTORY_MAX_MESSAGES = parseInt(j.historyMaxMessages, 10) || HISTORY_MAX_MESSAGES; } catch (e) {}
                }
                // update default UI flags coming from server config
                if (typeof j.defaultUseKnowledge !== 'undefined' && !localStorage.getItem('use_knowledge') && useKnowledgeCheckbox) {
                    useKnowledgeCheckbox.checked = !!j.defaultUseKnowledge;
                }
                if (typeof j.defaultStylizeResponse !== 'undefined' && !localStorage.getItem('stylized_response') && stylizedCheckbox) {
                    stylizedCheckbox.checked = !!j.defaultStylizeResponse;
                }
                if (typeof j.defaultShortResponse !== 'undefined' && !localStorage.getItem('short_responses') && shortResponsesCheckbox) {
                    shortResponsesCheckbox.checked = !!j.defaultShortResponse;
                }
                if (typeof j.defaultRememberHistory !== 'undefined' && !localStorage.getItem('remember_history') && rememberCheckbox) {
                    rememberCheckbox.checked = !!j.defaultRememberHistory;
                    rememberHistory = !!j.defaultRememberHistory;
                }
            } catch (err) {
                console.warn('Could not fetch config', err);
            }
        }
        // do not call updateKeyStatus until page variables are defined (modelSelect)
        // --- Simple chat UI + modal logic + conversation history
        // In-memory conversation history. Persisted to localStorage only if the user enables "Se souvenir".
        // Structure: [{ role: 'user'|'assistant'|'system', content: '...' }, ...]
        let conversationHistory = [];
        // Client-side limit for history that mirrors server's HISTORY_MAX_MESSAGES
        // This is updated dynamically when the UI fetches `/config`.
        let HISTORY_MAX_MESSAGES = 24; // keep last X messages
        let rememberHistory = false;
        // UI references
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('sendBtn');
        const openKeyModalBtn = document.getElementById('openKeyModal');
        const keyModal = document.getElementById('keyModal');
        const closeKeyModalBtn = document.getElementById('closeKeyModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveKeyBtn = document.getElementById('saveKeyBtn');
        const saveModelBtn = document.getElementById('saveModelBtn');
        const testKeyBtn = document.getElementById('testKeyBtn');
        const modalStatus = document.getElementById('modalStatus');
        const modelSelect = document.getElementById('modelSelect');
        const openChatBubbleBtn = document.getElementById('openChatBubble');
        const chatModal = document.getElementById('chatModal');
        const closeChatBtn = document.getElementById('closeChatBtn');

        // Append a message to the chat UI
        // role: 'user' | 'assistant'
        // text: message text (assistant messages are sanitized and rendered as Markdown)
        // skipHistory: if true, the message will not be stored into `conversationHistory` (useful when re-hydrating)
        function appendMessage(role, text, skipHistory=false) {
            const wrapper = document.createElement('div');
            wrapper.className = role === 'user' ? 'flex items-start gap-2.5 justify-end' : 'flex items-start gap-2.5';
            const inner = document.createElement('div');
            inner.className = 'flex flex-col gap-1 w-full max-w-[320px]';
            const profile = document.createElement('div');
            profile.className = 'flex items-center ' + (role === 'user' ? 'justify-end space-x-2 rtl:space-x-reverse' : 'space-x-2');
            const name = document.createElement('span');
            name.className = 'text-sm font-semibold text-gray-900';
            name.textContent = role === 'user' ? 'Vous' : 'IA';
            const time = document.createElement('span');
            time.className = 'text-xs font-normal text-gray-500';
            time.textContent = 'Maintenant';
            profile.appendChild(role === 'user' ? time : name);
            profile.appendChild(role === 'user' ? name : time);

            const bubble = document.createElement('div');
            bubble.className = role === 'user' ? 'leading-1.5 p-4 border-gray-200 bg-blue-600 text-white rounded-s-xl rounded-ee-xl shadow-sm bubble-user' : 'leading-1.5 p-4 border-gray-200 bg-white rounded-e-xl rounded-es-xl shadow-sm bubble-assistant';
            // Assistant messages are treated as Markdown and sanitized
            if (role === 'assistant') {
                // Render markdown + sanitize + convert color tags
                try {
                    const html = renderAssistantMarkdown(text);
                    bubble.innerHTML = html;
                } catch (e) {
                    bubble.innerHTML = '<p class="text-sm font-normal text-gray-900">' + text.replace(/\n/g, '<br>') + '</p>';
                }
            } else {
                bubble.innerHTML = '<p class="text-sm font-normal">' + text.replace(/\n/g, '<br>') + '</p>';
            }

            inner.appendChild(profile);
            inner.appendChild(bubble);
            wrapper.appendChild(inner);
            chatContainer.appendChild(wrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            // Optionally store in memory/localStorage — trim to the last HISTORY_MAX_MESSAGES
            if (!skipHistory) {
                // push to memory
                conversationHistory.push({ role, content: text });
                // trim
                if (conversationHistory.length > HISTORY_MAX_MESSAGES) {
                    conversationHistory = conversationHistory.slice(-HISTORY_MAX_MESSAGES);
                }
                // persist if requested
                if (rememberHistory) {
                    try { localStorage.setItem('chat_history', JSON.stringify(conversationHistory)); } catch (e) { /* ignore */ }
                }
            }
        }

        // Show a loading indicator while waiting for the assistant response
        function showLoading() {
            // remove previous if any
            const existing = document.getElementById('loadingBubble');
            if (existing) existing.remove();
            const wrapper = document.createElement('div');
            wrapper.className = 'flex items-start gap-2.5';
            wrapper.id = 'loadingBubble';
            const profile = document.createElement('div');
            profile.className = 'w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center text-blue-600 avatar-bot';
            profile.innerHTML = '<i data-lucide="bot" class="w-5 h-5"></i>';
            const inner = document.createElement('div');
            inner.className = 'flex flex-col gap-1 w-full max-w-[320px]';
            const bubble = document.createElement('div');
            bubble.className = 'leading-1.5 p-4 border-gray-200 bg-white rounded-e-xl rounded-es-xl shadow-sm';
            // spinner
            bubble.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
            inner.appendChild(bubble);
            wrapper.appendChild(profile);
            wrapper.appendChild(inner);
            chatContainer.appendChild(wrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            // disable input
            try { userInput.setAttribute('disabled', 'disabled'); sendBtn.setAttribute('disabled', 'disabled'); } catch (e) {}
            try { lucide.createIcons(); } catch (e) {}
        }

        // Remove the loading indicator and re-enable the input
        function hideLoading() {
            const existing = document.getElementById('loadingBubble');
            if (existing) existing.remove();
            try { userInput.removeAttribute('disabled'); sendBtn.removeAttribute('disabled'); } catch (e) {}
        }

        // Form submission: send user's message to the server via POST /chat, including conversation history
        document.querySelector('form').addEventListener('submit', async () => {
            const text = userInput.value.trim();
            if (!text) return;
            // send previous history to server, not including current input
            const historyToSend = conversationHistory.slice();
            appendMessage('user', text);
            showLoading();
            userInput.value = '';
            try {
                // POST /chat: message payload includes `message`, `model`, `history`, and UI flags
                const res = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text, model: modelSelect.value, history: historyToSend, useKnowledge: (useKnowledgeCheckbox ? useKnowledgeCheckbox.checked : true), shortResponse: (shortResponsesCheckbox ? shortResponsesCheckbox.checked : false), stylizeResponse: (stylizedCheckbox ? stylizedCheckbox.checked : true) })
                });
                const json = await res.json();
                if (!json.ok) {
                    hideLoading();
                    appendMessage('assistant', 'Erreur: ' + (json.error || 'réponse inattendue')); // assistant alias
                    return;
                }
                hideLoading();
                appendMessage('assistant', json.reply || 'Aucune réponse');
            } catch (err) {
                hideLoading();
                appendMessage('assistant', 'Erreur lors de la requête: ' + err.message);
            }
        });

        // Modal open/close handlers
        openKeyModalBtn.addEventListener('click', () => keyModal.classList.remove('hidden'));
        closeKeyModalBtn.addEventListener('click', () => keyModal.classList.add('hidden'));

        // Open/close chat modal via bubble
        openChatBubbleBtn.addEventListener('click', () => {
            chatModal.classList.remove('hidden');
            chatModal.classList.add('flex');
            openChatBubbleBtn.setAttribute('aria-expanded', 'true');
            // focusable for quick typing
            setTimeout(() => userInput.focus(), 150);
        });
        closeChatBtn.addEventListener('click', () => {
            chatModal.classList.add('hidden');
            chatModal.classList.remove('flex');
            openChatBubbleBtn.setAttribute('aria-expanded', 'false');
            openChatBubbleBtn.focus();
        });
        // allow clicking outside panel to close
        chatModal.addEventListener('click', (e) => {
            if (e.target === chatModal) {
                chatModal.classList.add('hidden');
                chatModal.classList.remove('flex');
                openChatBubbleBtn.setAttribute('aria-expanded', 'false');
                openChatBubbleBtn.focus();
            }
        });
        // Escape to close
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !chatModal.classList.contains('hidden')) {
                chatModal.classList.add('hidden');
                chatModal.classList.remove('flex');
                openChatBubbleBtn.setAttribute('aria-expanded', 'false');
                openChatBubbleBtn.focus();
            }
        });

        // Save the API key on the server for convenience. Reminder: do not do this for production.
        saveKeyBtn.addEventListener('click', async () => {
            const key = apiKeyInput.value.trim();
            if (!key) { modalStatus.textContent = 'Clé manquante'; return; }
            modalStatus.textContent = 'Enregistrement...';
            try {
                const res = await fetch('/set-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key })
                });
                const json = await res.json();
                if (!json.ok) throw new Error(json.error || 'Erreur');
                modalStatus.textContent = 'Clé enregistrée — redémarrez le serveur pour la prendre en compte.';
                // Clear or advise about not saving model here — model persistence is now separate
                modalStatus.textContent += ' (Modèle non modifié)';
            } catch (err) {
                modalStatus.textContent = 'Erreur: ' + err.message;
            }
        });

        // Save chosen model server-side so the server defaults to it for subsequent requests
        // This persists to `.env` via the server `/set-model` endpoint.
        // Model options are available to override per request from the client.
        // New handler: save only the model via /set-model
        saveModelBtn.addEventListener('click', async () => {
            const chosenModel = modelSelect.value;
            modalStatus.textContent = 'Enregistrement du modèle...';
            try {
                const r = await fetch('/set-model', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model: chosenModel }) });
                const j = await r.json();
                if (!j.ok) throw new Error(j.error || 'Erreur en enregistrant le modèle');
                modalStatus.textContent = 'Modèle enregistré: ' + chosenModel;
                updateKeyStatus();
                // update header status to reflect new model if needed
            } catch (err) {
                modalStatus.textContent = 'Erreur (modèle): ' + err.message;
            }
        });

        // Test the provided API key by temporarily writing it to the server and calling the chat endpoint
        testKeyBtn.addEventListener('click', async () => {
            modalStatus.textContent = 'Test en cours...';
            const key = apiKeyInput.value.trim();
            if (!key) { modalStatus.textContent = 'Clé manquante'; return; }
            try {
                // Keep a simple quick test (do not store); call /chat with a test prompt by proxy to validate key
                const testPrompt = 'Say hello in one sentence.';
                // Temporary test: we call the server set-key then test chat instantly
                // We use set-key to temporarily write and then call /chat
                const setRes = await fetch('/set-key', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key })
                });
                const setJson = await setRes.json();
                if (!setJson.ok) throw new Error(setJson.error || 'Failed to set');

                const chatRes = await fetch('/chat', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: testPrompt, model: modelSelect.value })
                });
                const chatJson = await chatRes.json();
                if (!chatJson.ok) throw new Error(chatJson.error || 'Chat failed');
                modalStatus.textContent = 'Clé OK — réponse test: ' + (chatJson.reply || 'pas de réponse');
            } catch (err) {
                modalStatus.textContent = 'Échec du test: ' + err.message;
            }
        });
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const rememberCheckbox = document.getElementById('rememberCheckbox');
        const useKnowledgeCheckbox = document.getElementById('useKnowledgeCheckbox');
        const shortResponsesCheckbox = document.getElementById('shortResponsesCheckbox');
        const stylizedCheckbox = document.getElementById('stylizedCheckbox');
        const setMaxCharsBtn = document.getElementById('setMaxCharsBtn');
        rememberHistory = !!localStorage.getItem('remember_history');
                                if (rememberCheckbox) rememberCheckbox.checked = rememberHistory;
        // Restore persisted setting for knowledge base
        try {
            const s = localStorage.getItem('use_knowledge');
            if (useKnowledgeCheckbox) {
                if (s !== null) {
                    useKnowledgeCheckbox.checked = s === '1';
                } else {
                    useKnowledgeCheckbox.checked = true; // default
                }
            }
        } catch (e) { if (useKnowledgeCheckbox) useKnowledgeCheckbox.checked = true; }
        // restore short response setting
        try {
            const r = localStorage.getItem('short_responses');
            if (shortResponsesCheckbox) shortResponsesCheckbox.checked = r === '1';
        } catch (e) { if (shortResponsesCheckbox) shortResponsesCheckbox.checked = false; }
        // restore stylized setting
        try {
            const r = localStorage.getItem('stylized_response');
            if (stylizedCheckbox) stylizedCheckbox.checked = r === '1';
        } catch (e) { if (stylizedCheckbox) stylizedCheckbox.checked = true; }

        // Clear the conversation both in-memory and in localStorage
        clearHistoryBtn.addEventListener('click', () => {
            conversationHistory = [];
            localStorage.removeItem('chat_history');
            chatContainer.innerHTML = '';
            appendMessage('assistant', 'Bonjour ! Je suis votre assistant virtuel. Comment puis-je vous aider aujourd\'hui ?');
        });

        // Toggle memory persistence: when enabled, conversationHistory is also saved to localStorage
                                if (rememberCheckbox) {
                                rememberCheckbox.addEventListener('change', () => {
            rememberHistory = rememberCheckbox.checked;
            try {
                localStorage.setItem('remember_history', rememberHistory ? '1' : '0');
            } catch (e) { }
            if (!rememberHistory) {
                localStorage.removeItem('chat_history');
            } else {
                try { localStorage.setItem('chat_history', JSON.stringify(conversationHistory)); } catch (e) { }
            }
                            });
                            }

                                if (useKnowledgeCheckbox) {
                                useKnowledgeCheckbox.addEventListener('change', () => {
                                    try { localStorage.setItem('use_knowledge', useKnowledgeCheckbox.checked ? '1' : '0'); } catch (e) { }
                                });
                                }
                                if (shortResponsesCheckbox) {
                                shortResponsesCheckbox.addEventListener('change', () => {
                                    try { localStorage.setItem('short_responses', shortResponsesCheckbox.checked ? '1' : '0'); } catch (e) { }
                                });
                                }
                                if (stylizedCheckbox) {
                                stylizedCheckbox.addEventListener('change', () => {
                                    try { localStorage.setItem('stylized_response', stylizedCheckbox.checked ? '1' : '0'); } catch (e) { }
                                });
                            }

        // Allow the user to set the MAX_RESPONSE_CHARS server-side through /set-config
        if (setMaxCharsBtn) {
            setMaxCharsBtn.addEventListener('click', async () => {
                const currentText = document.getElementById('maxCharsDisplay').textContent || 'Max: ?';
                const current = parseInt(currentText.replace(/[^0-9]/g, ''), 10) || 1000;
                const input = prompt('Définir la limite de caractères pour les réponses du chatbot (MAX_RESPONSE_CHARS):', String(current));
                if (!input) return;
                const n = parseInt(input, 10);
                if (Number.isNaN(n) || n < 10) { alert('Valeur invalide'); return; }
                try {
                    const r = await fetch('/set-config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: 'MAX_RESPONSE_CHARS', value: String(n) }) });
                    const j = await r.json();
                    if (!j.ok) throw new Error(j.error || 'Erreur');
                    // update the displayed value
                    document.getElementById('maxCharsDisplay').textContent = 'Max: ' + j.value;
                    alert('Max response chars mis à jour: ' + j.value);
                } catch (err) {
                    alert('Erreur: ' + err.message);
                }
            });
        }

                    // useKnowledge change listener is attached conditionally above (if element exists)

        // Hydrate persisted conversation from localStorage if present (and render it without duplicating history)
        chatContainer.innerHTML = '';
        (function loadPersistedHistory() {
            try {
                const r = localStorage.getItem('chat_history');
                if (r) {
                    const arr = JSON.parse(r);
                    if (Array.isArray(arr)) {
                        conversationHistory = arr.slice(-HISTORY_MAX_MESSAGES);
                        // render without pushing again to history
                        chatContainer.innerHTML = '';
                        for (const m of conversationHistory) {
                            appendMessage(m.role, m.content, true);
                        }
                        return;
                    }
                }
            } catch (e) {}
            // nothing persisted: show default
            appendMessage('assistant', 'Bonjour ! Je suis votre assistant virtuel. Comment puis-je vous aider aujourd\'hui ?');
        })();
        // now we can fetch server config and update UI status
        updateKeyStatus();
        // helper: render markdown with custom color tag handling
        function renderAssistantMarkdown(mdText) {
            // Convert custom [color=...] tags to inline styles before parsing markdown
            const colored = mdText.replace(/\[color=([^\]]+)\]([\s\S]*?)\[\/color\]/gi, (m, c, inner) => {
                // sanitize color to avoid injection - allow hex or simple color words
                const color = c.trim();
                return `<span style="color:${color}">${inner}</span>`;
            });
            // Use marked to parse markdown → HTML
            const rawHtml = marked.parse(colored);
            // sanitize
            const safe = DOMPurify.sanitize(rawHtml, { ALLOWED_ATTR: ['href', 'target', 'style', 'class'] });
            // Ensure anchors open in a new tab and are secure (rel=noopener noreferrer)
            const wrapper = document.createElement('div');
            wrapper.className = 'text-sm font-normal';
            wrapper.innerHTML = safe;
            const anchors = wrapper.querySelectorAll('a');
            anchors.forEach(a => {
                a.setAttribute('target', '_blank');
                // Ensure security attributes
                const existingRel = (a.getAttribute('rel') || '');
                const relParts = new Set(existingRel.split(' ').filter(Boolean));
                relParts.add('noopener'); relParts.add('noreferrer');
                a.setAttribute('rel', Array.from(relParts).join(' '));
                // Add a helper class for styling
                a.classList.add('assistant-link');
            });
            return wrapper.innerHTML;
        }

    document.getElementById('settingsBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        const dropdown = document.getElementById('settingsDropdown');
        dropdown.classList.toggle('hidden');
    });

    document.addEventListener('click', () => {
        document.getElementById('settingsDropdown').classList.add('hidden');
    });
    </script>
</body>

</html>